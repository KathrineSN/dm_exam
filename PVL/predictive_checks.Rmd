

```{r, include=FALSE}

# Installing packages
install.packages("pacman")
pacman::p_load(R2jags, parallel, ggplot2, tidyverse)
set.seed(1982)
```

```{r}
# defining a function for calculating the maximum of the posterior density (not exactly the same as the mode)

MPD <- function(x) {
  density(x)$x[which(density(x)$y==max(density(x)$y))]
}
```


```{r}
load("../data/IGTdata.rdata") 

choice_100 <- as.data.frame(choice_100)
wi_100 <- as.data.frame(wi_100)
lo_100 <- as.data.frame(lo_100)
```

```{r}
df_final <- data.frame()

for (i in 1:nrow(choice_100)) {
  # creating trial, deck and subID columns 
  sub_choice = choice_100 %>% slice(i)
  sub_choice = gather(sub_choice, "trial", "deck")
  
  sub_choice <- sub_choice %>% 
    mutate(
      trial = gsub("Choice_", "", trial)
    )
  
  # adding gain column 
  sub_win <- wi_100 %>% slice(i)
  sub_win <- gather(sub_win, "trial", "gain")
  sub_win <- sub_win %>% 
    mutate(
      trial = gsub("Wins_", "", trial)
    )

  # adding loss
  sub_loss = lo_100 %>% slice(i)
  sub_loss <- gather(sub_loss, "trial", "loss")
  sub_loss <- sub_loss %>% 
    mutate(
      trial = gsub("Losses_", "", trial),
      subjID = i # adding subject ID
    )

  # join dataframe
  first_join = full_join(sub_choice, sub_win, by = "trial")
  second_join = left_join(first_join, sub_loss, by = "trial")
  
  df_final <- rbind(df_final, second_join)
}
```

```{r}
# Identify choices, subjects and outcomes
# identify and count unique subject IDs
subIDs <- unique(df_final$subjID)
nsubs <- length(subIDs)
ntrials_max <- 100

# all choices (x) and outcomes (X)
x_raw <- df_final$deck
X_raw <- df_final$gain + df_final$loss #note the sign!

```

```{r}
#--- assign choices and outcomes in trial x sub matrix

#different number of trials across subjects. We'll need to fix this by padding arrays of < 100
#this is just so we can make the array
#then we'll also need to record number of valid trials for each sub, 
#then run the JAGS model on only valid trials

# empty arrays to fill
ntrials_all <- array(0,c(nsubs))
x_all <- array(0,c(nsubs,ntrials_max))
X_all <- array(0,c(nsubs,ntrials_max))

for (s in 1:nsubs) {
  
  #record n trials for subject s
  ntrials_all[s] <- length(x_raw[df_final$subjID==subIDs[s]])
  
  #pad trials with NA if n trials < maximum (i.e. 100)
  x_sub <- x_raw[df_final$subjID==subIDs[s]] 
  length(x_sub) <- ntrials_max
  
  X_sub <- X_raw[df_final$subjID==subIDs[s]] 
  length(X_sub) <- ntrials_max
  
  # assign arrays
  x_all[s,] <- x_sub
  X_all[s,] <- X_sub
}
```

```{r}
getwd()
```



```{r}
#----------testing our data curation by running JAGS on one subject

# Now we'll fit one subject just to make sure everything works

x <- x_all[1,] # selecting choices from subj 1
X <- X_all[1,] # selecting payoffs from subj 1

ntrials <- ntrials_all[1]

# set up jags and run jags model on one subject
data <- list("x","X","ntrials") 
params<-c("w","A","theta","a","p")
temp_samples <- jags.parallel(data, inits=NULL, params,
                              model.file ="PVL.txt",
                              n.chains=3, n.iter=5000, n.burnin=1000, n.thin=1, n.cluster=4)

# let's look at the posteriors for the parameters
par(mfrow=c(2,2))
plot(density(temp_samples$BUGSoutput$sims.list$w))
plot(density(temp_samples$BUGSoutput$sims.list$A))
plot(density(temp_samples$BUGSoutput$sims.list$theta))
plot(density(temp_samples$BUGSoutput$sims.list$a))
```


```{r}
#----------Posterior predictive checks of descriptive accuracy

# Posterior prediction - start by looking at posteriors for p parameter

p_post <- temp_samples$BUGSoutput$sims.list$p # probabilities as the outcome from softmax

#plot probability of each deck on trial 84
par(mfrow=c(2,2))
plot(density(p_post[,84,1]))
plot(density(p_post[,84,2]))
plot(density(p_post[,84,3]))
plot(density(p_post[,84,4]))

# which option will be chosen?
x[84]
# is this a good prediction?

# let's write a loop that loop and see how the model goes at predicting responses for all trials 
x_predict <- array(ntrials)

for (t in 1:ntrials) {
  
  p_predict <- c(
    MPD(p_post[,t,1]),
    MPD(p_post[,t,2]),
    MPD(p_post[,t,3]),
    MPD(p_post[,t,4])
  )
  
  x_predict[t] <- which.max(p_predict)
}
# how well did our model do?
sum(x_predict==x)


# let's see how the model goes for more than 1 subject. Let's run this on all subjects
pred_success <- array(nsubs)

start_time = Sys.time()

for (s in 1:nsubs) {
  
  x <- x_all[s, ]
  X <- X_all[s, ]
  
  ntrials <- ntrials_all[s]
  
  # set up jags and run jags model on one subject
  data <- list("x","X","ntrials") 
  params<-c("w","A","theta","a","p")
  temp_samples <- jags.parallel(data, inits=NULL, params,
                                model.file ="PVL.txt",
                                n.chains=3, n.iter=5000, n.burnin=1000, n.thin=1, n.cluster=4)
  
  p_post <- temp_samples$BUGSoutput$sims.list$p
  
  x_predict <- array(ntrials)
  
  for (t in 1:ntrials) {
    p_predict <- c(
      MPD(p_post[,t,1]),
      MPD(p_post[,t,2]),
      MPD(p_post[,t,3]),
      MPD(p_post[,t,4])
    )
    
    x_predict[t] <- which.max(p_predict)
    
  }
  
  pred_success[s] <- sum(x_predict==x[1:ntrials]) # only comparing with trials for which we have choices
  print(s)
  
}

end_time = Sys.time()
end_time - start_time

pred_success_adjust <- pred_success/ntrials_all

avg_pred <- mean(pred_success_adjust)

# plotting code courtesy of Mia
pred_df <- data.frame(pred_success_adjust)
pred_df$sub <- 1:length(pred_success_adjust) # rownames(pred_df) # creating a subject index
pred_df$avg <- mean(pred_df$pred_success)
pred_df$std <- sd(pred_df$pred_success)
pred_df$chance <- .25
ggplot(pred_df, aes(sub, pred_success_adjust)) +
  geom_point() +
  geom_line(aes(y=chance), linetype="dashed", color = "black") +
  geom_ribbon(aes(xmin = -Inf, xmax = Inf, ymin = avg - std, ymax = avg + std), fill = "pink", alpha = 0.6) + 
  geom_line(aes(y=avg))
```



